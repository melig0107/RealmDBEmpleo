// This file is generated: Update the spec instead of editing this file directly
#include <realm/status.hpp>
#include <realm/object-store/shared_realm.hpp>
#include <realm/object-store/object_store.hpp>
#include <realm/object-store/object_schema.hpp>
#include <realm/object-store/results.hpp>
#include <realm/object-store/thread_safe_reference.hpp>
#include <realm/object-store/util/scheduler.hpp>
#include <realm/object-store/collection_notifications.hpp>
#include <realm/object-store/impl/object_notifier.hpp>
#include <realm/object-store/impl/realm_coordinator.hpp>
#include <realm/util/bson/bson.hpp>
#include <platform.hpp>

#include <jsi/jsi.h>
#include <chrono>
#include <realm_js_jsi_helpers.h>

// Using all-caps JSI to avoid risk of conflicts with jsi namespace from fb.
namespace realm::js::JSI {
namespace {

class RealmAddon;
jsi::Value Helpers_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_keypath_mapping([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_results_append_query([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_object_notifier([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
Helpers::BindingContextMethods STRUCT_FROM_JS_BindingContext(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_set_binding_context([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_or_create_object_with_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count);
jsi::Value Helpers_delete_data_for_object([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_base64_decode([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_logger([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_consume_thread_safe_reference_to_shared_realm([[maybe_unused]] jsi::Runtime& _env,
                                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                                 [[maybe_unused]] const jsi::Value* args,
                                                                 [[maybe_unused]] size_t count);
jsi::Value Helpers_file_exists([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_results_description([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
Property STRUCT_FROM_JS_Property(jsi::Runtime& _env, auto&& val);
ObjectSchema STRUCT_FROM_JS_ObjectSchema(jsi::Runtime& _env, auto&& val);
RealmConfig STRUCT_FROM_JS_RealmConfig(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_needs_file_format_upgrade([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Helpers& JS_TO_CLASS_Helpers(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value LogCategoryRef_set_default_level_threshold([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count);
jsi::Value LogCategoryRef_get_category([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] util::LogCategoryRef& JS_TO_CLASS_LogCategoryRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_LogCategoryRef(jsi::Runtime& _env, util::LogCategoryRef val);
jsi::Value Logger_set_default_logger([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<util::Logger>& JS_TO_SHARED_Logger(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Logger(jsi::Runtime& _env, std::shared_ptr<util::Logger> val);
jsi::Value ConstTableRef_get_column_type([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_try_get_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_find_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] ConstTableRef& JS_TO_CLASS_ConstTableRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ConstTableRef(jsi::Runtime& _env, ConstTableRef val);
jsi::Value TableRef_create_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_remove_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_get_primary_key_column([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] TableRef& JS_TO_CLASS_TableRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_TableRef(jsi::Runtime& _env, TableRef val);
jsi::Value Obj_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_add_int([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_linked_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_backlink_count([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_backlink_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_create_and_set_linked_object([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Obj& JS_TO_CLASS_Obj(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Obj(jsi::Runtime& _env, Obj val);
[[maybe_unused]] const std::shared_ptr<Transaction>& JS_TO_SHARED_Transaction(jsi::Runtime& _env,
                                                                              const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Transaction(jsi::Runtime& _env, std::shared_ptr<Transaction> val);
[[maybe_unused]] ObjectStore& JS_TO_CLASS_ObjectStore(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ObjectStore(jsi::Runtime& _env, ObjectStore val);
jsi::Value Timestamp_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Timestamp_get_seconds([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Timestamp_get_nanoseconds([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Timestamp& JS_TO_CLASS_Timestamp(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Timestamp(jsi::Runtime& _env, Timestamp val);
GeoPoint STRUCT_FROM_JS_GeoPoint(jsi::Runtime& _env, auto&& val);
GeoCircle STRUCT_FROM_JS_GeoCircle(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_circle([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
GeoBox STRUCT_FROM_JS_GeoBox(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_box([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
GeoPolygon STRUCT_FROM_JS_GeoPolygon(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_polygon([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Geospatial& JS_TO_CLASS_Geospatial(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Geospatial(jsi::Runtime& _env, Geospatial val);
jsi::Value ObjLink_get_table_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ObjLink_get_obj_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] ObjLink& JS_TO_CLASS_ObjLink(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ObjLink(jsi::Runtime& _env, ObjLink val);
[[maybe_unused]] query_parser::KeyPathMapping& JS_TO_CLASS_KeyPathMapping(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_KeyPathMapping(jsi::Runtime& _env, query_parser::KeyPathMapping val);
jsi::Value Query_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Query_get_description([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Query& JS_TO_CLASS_Query(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Query(jsi::Runtime& _env, Query val);
[[maybe_unused]] SortDescriptor& JS_TO_CLASS_SortDescriptor(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_SortDescriptor(jsi::Runtime& _env, SortDescriptor val);
[[maybe_unused]] TableView& JS_TO_CLASS_TableView(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_TableView(jsi::Runtime& _env, TableView val);
jsi::Value Results_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_index_of([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_index_of_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_sort_by_names([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_max([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_min([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_average([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_sum([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_CollectionChangeSet(jsi::Runtime& _env, const CollectionChangeSet& in);
jsi::Value Results_add_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_from_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_from_table_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_object_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Results& JS_TO_CLASS_Results(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Results(jsi::Runtime& _env, Results val);
jsi::Value Realm_begin_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_commit_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_cancel_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_update_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_compact([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_convert([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_verify_open([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_create_key_path_array([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_shared_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_Property(jsi::Runtime& _env, const Property& in);
jsi::Value STRUCT_TO_JS_ObjectSchema(jsi::Runtime& _env, const ObjectSchema& in);
jsi::Value STRUCT_TO_JS_RealmConfig(jsi::Runtime& _env, const RealmConfig& in);
jsi::Value Realm_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_in_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_in_migration([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_empty([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_closed([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_DOLLAR_addr([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<Realm>& JS_TO_SHARED_Realm(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Realm(jsi::Runtime& _env, std::shared_ptr<Realm> val);
jsi::Value RealmCoordinator_clear_all_caches([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<_impl::RealmCoordinator>& JS_TO_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                                                               const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                            std::shared_ptr<_impl::RealmCoordinator> val);
jsi::Value STRUCT_TO_JS_ObjectChangeSet(jsi::Runtime& _env, const ObjectChangeSet& in);
jsi::Value ObjectNotifier_add_callback([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<_impl::ObjectNotifier>& JS_TO_SHARED_ObjectNotifier(jsi::Runtime& _env,
                                                                                           const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_ObjectNotifier(jsi::Runtime& _env,
                                                          std::shared_ptr<_impl::ObjectNotifier> val);
jsi::Value NotificationToken_unregister([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value NotificationToken_for_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] NotificationToken& JS_TO_CLASS_NotificationToken(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_NotificationToken(jsi::Runtime& _env, NotificationToken val);
jsi::Value IndexSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] IndexSet& JS_TO_CLASS_IndexSet(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_IndexSet(jsi::Runtime& _env, IndexSet val);
jsi::Value Collection_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_as_results([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_get_object_schema([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Collection& JS_TO_CLASS_Collection(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value List_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_move([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_remove([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_swap([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] List& JS_TO_CLASS_List(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_List(jsi::Runtime& _env, List val);
jsi::Value Set_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_remove_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Set& JS_TO_CLASS_Set(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Set(jsi::Runtime& _env, object_store::Set val);
jsi::Value Dictionary_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_dictionary([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_contains([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_DictionaryChangeSet(jsi::Runtime& _env, const DictionaryChangeSet& in);
jsi::Value Dictionary_add_key_based_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_embedded([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_collection([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_try_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_try_erase([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_keys([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_values([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Dictionary& JS_TO_CLASS_Dictionary(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Dictionary(jsi::Runtime& _env, object_store::Dictionary val);
[[maybe_unused]] std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>&
JS_TO_CLASS_LoggerFactory(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value
JS_FROM_CLASS_LoggerFactory(jsi::Runtime& _env,
                            std::function<std::shared_ptr<util::Logger>(util::Logger::Level)> val);
[[maybe_unused]] ThreadSafeReference& JS_TO_CLASS_ThreadSafeReference(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ThreadSafeReference(jsi::Runtime& _env, ThreadSafeReference val);
[[maybe_unused]] const std::shared_ptr<util::Scheduler>& JS_TO_SHARED_Scheduler(jsi::Runtime& _env,
                                                                                const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Scheduler(jsi::Runtime& _env, std::shared_ptr<util::Scheduler> val);
jsi::Value JsPlatformHelpers_set_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_ensure_directory_exists_for_file([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_copy_bundled_realm_files([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_realm_files_from_directory([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_file([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_directory([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_exclude_from_icloud_backup([[maybe_unused]] jsi::Runtime& _env,
                                                        [[maybe_unused]] const jsi::Value& thisValue,
                                                        [[maybe_unused]] const jsi::Value* args,
                                                        [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_get_cpu_arch([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] JsPlatformHelpers& JS_TO_CLASS_JsPlatformHelpers(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value JS_FROM_Mixed(jsi::Runtime& _env, Mixed val);
Mixed JS_TO_Mixed(jsi::Runtime& _env, auto&& val);
int64_t bigIntToI64(jsi::Runtime& _env, auto&& val);
uint64_t bigIntToU64(jsi::Runtime& _env, auto&& val);
jsi::Value bigIntFromI64(jsi::Runtime& _env, int64_t val);
jsi::Value bigIntFromU64(jsi::Runtime& _env, uint64_t val);
jsi::Value createWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value lockWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
class RealmAddon {
public:
    inline const std::string& wrapString(std::string str);
    inline auto startCall();
    jsi::Value injectInjectables([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
    RealmAddon(jsi::Runtime& _env, jsi::Object& exports);

    std::deque<std::string> m_string_bufs;
    static std::unique_ptr<RealmAddon> self;
    jsi::Runtime& m_rt;
    const bool m_on_hermes;
    std::optional<jsi::Function> m_cls_Long_ctor;
    std::optional<jsi::Function> m_cls_ArrayBuffer_ctor;
    std::optional<jsi::Function> m_cls_Float_ctor;
    std::optional<jsi::Function> m_cls_UUID_ctor;
    std::optional<jsi::Function> m_cls_ObjectId_ctor;
    std::optional<jsi::Function> m_cls_Decimal128_ctor;
    std::optional<jsi::Function> m_cls_EJSON_parse_ctor;
    std::optional<jsi::Function> m_cls_EJSON_stringify_ctor;
    std::optional<jsi::Function> m_cls_Symbol_for_ctor;
    std::optional<jsi::Function> m_cls_Helpers_ctor;
    std::optional<jsi::Function> m_cls_LogCategoryRef_ctor;
    std::optional<jsi::Function> m_cls_Logger_ctor;
    std::optional<jsi::Function> m_cls_ConstTableRef_ctor;
    std::optional<jsi::Function> m_cls_TableRef_ctor;
    std::optional<jsi::Function> m_cls_Obj_ctor;
    std::optional<jsi::Function> m_cls_Transaction_ctor;
    std::optional<jsi::Function> m_cls_ObjectStore_ctor;
    std::optional<jsi::Function> m_cls_Timestamp_ctor;
    std::optional<jsi::Function> m_cls_Geospatial_ctor;
    std::optional<jsi::Function> m_cls_ObjLink_ctor;
    std::optional<jsi::Function> m_cls_KeyPathMapping_ctor;
    std::optional<jsi::Function> m_cls_Query_ctor;
    std::optional<jsi::Function> m_cls_SortDescriptor_ctor;
    std::optional<jsi::Function> m_cls_TableView_ctor;
    std::optional<jsi::Function> m_cls_Results_ctor;
    std::optional<jsi::Function> m_cls_Realm_ctor;
    std::optional<jsi::Function> m_cls_RealmCoordinator_ctor;
    std::optional<jsi::Function> m_cls_ObjectNotifier_ctor;
    std::optional<jsi::Function> m_cls_NotificationToken_ctor;
    std::optional<jsi::Function> m_cls_IndexSet_ctor;
    std::optional<jsi::Function> m_cls_Collection_ctor;
    std::optional<jsi::Function> m_cls_List_ctor;
    std::optional<jsi::Function> m_cls_Set_ctor;
    std::optional<jsi::Function> m_cls_Dictionary_ctor;
    std::optional<jsi::Function> m_cls_LoggerFactory_ctor;
    std::optional<jsi::Function> m_cls_ThreadSafeReference_ctor;
    std::optional<jsi::Function> m_cls_Scheduler_ctor;
    std::optional<jsi::Function> m_cls_JsPlatformHelpers_ctor;
    std::optional<jsi::Function> m_cls_Helpers_extractor;
    std::optional<jsi::Function> m_cls_LogCategoryRef_extractor;
    std::optional<jsi::Function> m_cls_Logger_extractor;
    std::optional<jsi::Function> m_cls_ConstTableRef_extractor;
    std::optional<jsi::Function> m_cls_TableRef_extractor;
    std::optional<jsi::Function> m_cls_Obj_extractor;
    std::optional<jsi::Function> m_cls_Transaction_extractor;
    std::optional<jsi::Function> m_cls_ObjectStore_extractor;
    std::optional<jsi::Function> m_cls_Timestamp_extractor;
    std::optional<jsi::Function> m_cls_Geospatial_extractor;
    std::optional<jsi::Function> m_cls_ObjLink_extractor;
    std::optional<jsi::Function> m_cls_KeyPathMapping_extractor;
    std::optional<jsi::Function> m_cls_Query_extractor;
    std::optional<jsi::Function> m_cls_SortDescriptor_extractor;
    std::optional<jsi::Function> m_cls_TableView_extractor;
    std::optional<jsi::Function> m_cls_Results_extractor;
    std::optional<jsi::Function> m_cls_Realm_extractor;
    std::optional<jsi::Function> m_cls_RealmCoordinator_extractor;
    std::optional<jsi::Function> m_cls_ObjectNotifier_extractor;
    std::optional<jsi::Function> m_cls_NotificationToken_extractor;
    std::optional<jsi::Function> m_cls_IndexSet_extractor;
    std::optional<jsi::Function> m_cls_Collection_extractor;
    std::optional<jsi::Function> m_cls_List_extractor;
    std::optional<jsi::Function> m_cls_Set_extractor;
    std::optional<jsi::Function> m_cls_Dictionary_extractor;
    std::optional<jsi::Function> m_cls_LoggerFactory_extractor;
    std::optional<jsi::Function> m_cls_ThreadSafeReference_extractor;
    std::optional<jsi::Function> m_cls_Scheduler_extractor;
    std::optional<jsi::Function> m_cls_JsPlatformHelpers_extractor;
    jsi::PropNameID m_prop_didChange;
    jsi::PropNameID m_prop_bind;
    jsi::PropNameID m_prop_beforeNotify;
    jsi::PropNameID m_prop_schemaDidChange;
    jsi::PropNameID m_prop_path;
    jsi::PropNameID m_prop_cache;
    jsi::PropNameID m_prop_encryptionKey;
    jsi::PropNameID m_prop_fifoFilesFallbackPath;
    jsi::PropNameID m_prop_inMemory;
    jsi::PropNameID m_prop_schema;
    jsi::PropNameID m_prop_name;
    jsi::PropNameID m_prop_persistedProperties;
    jsi::PropNameID m_prop_publicName;
    jsi::PropNameID m_prop_type;
    jsi::PropNameID m_prop_objectType;
    jsi::PropNameID m_prop_linkOriginPropertyName;
    jsi::PropNameID m_prop_isPrimary;
    jsi::PropNameID m_prop_isIndexed;
    jsi::PropNameID m_prop_isFulltextIndexed;
    jsi::PropNameID m_prop_columnKey;
    jsi::PropNameID m_prop_computedProperties;
    jsi::PropNameID m_prop_primaryKey;
    jsi::PropNameID m_prop_tableKey;
    jsi::PropNameID m_prop_tableType;
    jsi::PropNameID m_prop_schemaVersion;
    jsi::PropNameID m_prop_schemaMode;
    jsi::PropNameID m_prop_disableFormatUpgrade;
    jsi::PropNameID m_prop_migrationFunction;
    jsi::PropNameID m_prop_initializationFunction;
    jsi::PropNameID m_prop_shouldCompactOnLaunchFunction;
    jsi::PropNameID m_prop_automaticallyHandleBacklinksInMigrations;
    jsi::PropNameID m_prop_next;
    jsi::PropNameID m_prop_done;
    jsi::PropNameID m_prop_value;
    jsi::PropNameID m_prop_radiusRadians;
    jsi::PropNameID m_prop_center;
    jsi::PropNameID m_prop_longitude;
    jsi::PropNameID m_prop_latitude;
    jsi::PropNameID m_prop_altitude;
    jsi::PropNameID m_prop_lo;
    jsi::PropNameID m_prop_hi;
    jsi::PropNameID m_prop_points;
    jsi::PropNameID m_prop_deletions;
    jsi::PropNameID m_prop_insertions;
    jsi::PropNameID m_prop_modifications;
    jsi::PropNameID m_prop_modificationsNew;
    jsi::PropNameID m_prop_isDeleted;
    jsi::PropNameID m_prop_changedColumns;
    jsi::PropNameID m_prop_high;
    jsi::PropNameID m_prop_low;
};
std::unique_ptr<RealmAddon> RealmAddon::self;
const std::string& RealmAddon::wrapString(std::string str)
{
    return m_string_bufs.emplace_back(std::move(str));
}
auto RealmAddon::startCall()
{
    return ContainerResizer(m_string_bufs);
}
jsi::Value RealmAddon::injectInjectables([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    auto ctors = args[0].asObject(_env);
    m_cls_Long_ctor = ctors.getProperty(_env, "Long").asObject(_env).asFunction(_env);
    m_cls_ArrayBuffer_ctor = ctors.getProperty(_env, "ArrayBuffer").asObject(_env).asFunction(_env);
    m_cls_Float_ctor = ctors.getProperty(_env, "Float").asObject(_env).asFunction(_env);
    m_cls_UUID_ctor = ctors.getProperty(_env, "UUID").asObject(_env).asFunction(_env);
    m_cls_ObjectId_ctor = ctors.getProperty(_env, "ObjectId").asObject(_env).asFunction(_env);
    m_cls_Decimal128_ctor = ctors.getProperty(_env, "Decimal128").asObject(_env).asFunction(_env);
    m_cls_EJSON_parse_ctor = ctors.getProperty(_env, "EJSON_parse").asObject(_env).asFunction(_env);
    m_cls_EJSON_stringify_ctor = ctors.getProperty(_env, "EJSON_stringify").asObject(_env).asFunction(_env);
    m_cls_Symbol_for_ctor = ctors.getProperty(_env, "Symbol_for").asObject(_env).asFunction(_env);
    m_cls_Helpers_ctor = ctors.getProperty(_env, "Helpers").asObject(_env).asFunction(_env);
    m_cls_LogCategoryRef_ctor = ctors.getProperty(_env, "LogCategoryRef").asObject(_env).asFunction(_env);
    m_cls_Logger_ctor = ctors.getProperty(_env, "Logger").asObject(_env).asFunction(_env);
    m_cls_ConstTableRef_ctor = ctors.getProperty(_env, "ConstTableRef").asObject(_env).asFunction(_env);
    m_cls_TableRef_ctor = ctors.getProperty(_env, "TableRef").asObject(_env).asFunction(_env);
    m_cls_Obj_ctor = ctors.getProperty(_env, "Obj").asObject(_env).asFunction(_env);
    m_cls_Transaction_ctor = ctors.getProperty(_env, "Transaction").asObject(_env).asFunction(_env);
    m_cls_ObjectStore_ctor = ctors.getProperty(_env, "ObjectStore").asObject(_env).asFunction(_env);
    m_cls_Timestamp_ctor = ctors.getProperty(_env, "Timestamp").asObject(_env).asFunction(_env);
    m_cls_Geospatial_ctor = ctors.getProperty(_env, "Geospatial").asObject(_env).asFunction(_env);
    m_cls_ObjLink_ctor = ctors.getProperty(_env, "ObjLink").asObject(_env).asFunction(_env);
    m_cls_KeyPathMapping_ctor = ctors.getProperty(_env, "KeyPathMapping").asObject(_env).asFunction(_env);
    m_cls_Query_ctor = ctors.getProperty(_env, "Query").asObject(_env).asFunction(_env);
    m_cls_SortDescriptor_ctor = ctors.getProperty(_env, "SortDescriptor").asObject(_env).asFunction(_env);
    m_cls_TableView_ctor = ctors.getProperty(_env, "TableView").asObject(_env).asFunction(_env);
    m_cls_Results_ctor = ctors.getProperty(_env, "Results").asObject(_env).asFunction(_env);
    m_cls_Realm_ctor = ctors.getProperty(_env, "Realm").asObject(_env).asFunction(_env);
    m_cls_RealmCoordinator_ctor = ctors.getProperty(_env, "RealmCoordinator").asObject(_env).asFunction(_env);
    m_cls_ObjectNotifier_ctor = ctors.getProperty(_env, "ObjectNotifier").asObject(_env).asFunction(_env);
    m_cls_NotificationToken_ctor = ctors.getProperty(_env, "NotificationToken").asObject(_env).asFunction(_env);
    m_cls_IndexSet_ctor = ctors.getProperty(_env, "IndexSet").asObject(_env).asFunction(_env);
    m_cls_Collection_ctor = ctors.getProperty(_env, "Collection").asObject(_env).asFunction(_env);
    m_cls_List_ctor = ctors.getProperty(_env, "List").asObject(_env).asFunction(_env);
    m_cls_Set_ctor = ctors.getProperty(_env, "Set").asObject(_env).asFunction(_env);
    m_cls_Dictionary_ctor = ctors.getProperty(_env, "Dictionary").asObject(_env).asFunction(_env);
    m_cls_LoggerFactory_ctor = ctors.getProperty(_env, "LoggerFactory").asObject(_env).asFunction(_env);
    m_cls_ThreadSafeReference_ctor = ctors.getProperty(_env, "ThreadSafeReference").asObject(_env).asFunction(_env);
    m_cls_Scheduler_ctor = ctors.getProperty(_env, "Scheduler").asObject(_env).asFunction(_env);
    m_cls_JsPlatformHelpers_ctor = ctors.getProperty(_env, "JsPlatformHelpers").asObject(_env).asFunction(_env);
    m_cls_Helpers_extractor = m_cls_Helpers_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_LogCategoryRef_extractor =
        m_cls_LogCategoryRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Logger_extractor = m_cls_Logger_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ConstTableRef_extractor =
        m_cls_ConstTableRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_TableRef_extractor = m_cls_TableRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Obj_extractor = m_cls_Obj_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Transaction_extractor =
        m_cls_Transaction_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjectStore_extractor =
        m_cls_ObjectStore_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Timestamp_extractor = m_cls_Timestamp_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Geospatial_extractor = m_cls_Geospatial_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjLink_extractor = m_cls_ObjLink_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_KeyPathMapping_extractor =
        m_cls_KeyPathMapping_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Query_extractor = m_cls_Query_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SortDescriptor_extractor =
        m_cls_SortDescriptor_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_TableView_extractor = m_cls_TableView_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Results_extractor = m_cls_Results_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Realm_extractor = m_cls_Realm_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_RealmCoordinator_extractor =
        m_cls_RealmCoordinator_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjectNotifier_extractor =
        m_cls_ObjectNotifier_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_NotificationToken_extractor =
        m_cls_NotificationToken_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_IndexSet_extractor = m_cls_IndexSet_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Collection_extractor = m_cls_Collection_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_List_extractor = m_cls_List_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Set_extractor = m_cls_Set_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Dictionary_extractor = m_cls_Dictionary_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_LoggerFactory_extractor =
        m_cls_LoggerFactory_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ThreadSafeReference_extractor =
        m_cls_ThreadSafeReference_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Scheduler_extractor = m_cls_Scheduler_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_JsPlatformHelpers_extractor =
        m_cls_JsPlatformHelpers_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);

    return jsi::Value::undefined();
}
RealmAddon::RealmAddon(jsi::Runtime& _env, jsi::Object& exports)
    : m_rt(_env)
    , m_on_hermes(_env.global().getProperty(_env, "HermesInternal").isObject())
    , m_prop_didChange(jsi::PropNameID::forAscii(_env, "didChange"))
    , m_prop_bind(jsi::PropNameID::forAscii(_env, "bind"))
    , m_prop_beforeNotify(jsi::PropNameID::forAscii(_env, "beforeNotify"))
    , m_prop_schemaDidChange(jsi::PropNameID::forAscii(_env, "schemaDidChange"))
    , m_prop_path(jsi::PropNameID::forAscii(_env, "path"))
    , m_prop_cache(jsi::PropNameID::forAscii(_env, "cache"))
    , m_prop_encryptionKey(jsi::PropNameID::forAscii(_env, "encryptionKey"))
    , m_prop_fifoFilesFallbackPath(jsi::PropNameID::forAscii(_env, "fifoFilesFallbackPath"))
    , m_prop_inMemory(jsi::PropNameID::forAscii(_env, "inMemory"))
    , m_prop_schema(jsi::PropNameID::forAscii(_env, "schema"))
    , m_prop_name(jsi::PropNameID::forAscii(_env, "name"))
    , m_prop_persistedProperties(jsi::PropNameID::forAscii(_env, "persistedProperties"))
    , m_prop_publicName(jsi::PropNameID::forAscii(_env, "publicName"))
    , m_prop_type(jsi::PropNameID::forAscii(_env, "type"))
    , m_prop_objectType(jsi::PropNameID::forAscii(_env, "objectType"))
    , m_prop_linkOriginPropertyName(jsi::PropNameID::forAscii(_env, "linkOriginPropertyName"))
    , m_prop_isPrimary(jsi::PropNameID::forAscii(_env, "isPrimary"))
    , m_prop_isIndexed(jsi::PropNameID::forAscii(_env, "isIndexed"))
    , m_prop_isFulltextIndexed(jsi::PropNameID::forAscii(_env, "isFulltextIndexed"))
    , m_prop_columnKey(jsi::PropNameID::forAscii(_env, "columnKey"))
    , m_prop_computedProperties(jsi::PropNameID::forAscii(_env, "computedProperties"))
    , m_prop_primaryKey(jsi::PropNameID::forAscii(_env, "primaryKey"))
    , m_prop_tableKey(jsi::PropNameID::forAscii(_env, "tableKey"))
    , m_prop_tableType(jsi::PropNameID::forAscii(_env, "tableType"))
    , m_prop_schemaVersion(jsi::PropNameID::forAscii(_env, "schemaVersion"))
    , m_prop_schemaMode(jsi::PropNameID::forAscii(_env, "schemaMode"))
    , m_prop_disableFormatUpgrade(jsi::PropNameID::forAscii(_env, "disableFormatUpgrade"))
    , m_prop_migrationFunction(jsi::PropNameID::forAscii(_env, "migrationFunction"))
    , m_prop_initializationFunction(jsi::PropNameID::forAscii(_env, "initializationFunction"))
    , m_prop_shouldCompactOnLaunchFunction(jsi::PropNameID::forAscii(_env, "shouldCompactOnLaunchFunction"))
    , m_prop_automaticallyHandleBacklinksInMigrations(
          jsi::PropNameID::forAscii(_env, "automaticallyHandleBacklinksInMigrations"))
    , m_prop_next(jsi::PropNameID::forAscii(_env, "next"))
    , m_prop_done(jsi::PropNameID::forAscii(_env, "done"))
    , m_prop_value(jsi::PropNameID::forAscii(_env, "value"))
    , m_prop_radiusRadians(jsi::PropNameID::forAscii(_env, "radiusRadians"))
    , m_prop_center(jsi::PropNameID::forAscii(_env, "center"))
    , m_prop_longitude(jsi::PropNameID::forAscii(_env, "longitude"))
    , m_prop_latitude(jsi::PropNameID::forAscii(_env, "latitude"))
    , m_prop_altitude(jsi::PropNameID::forAscii(_env, "altitude"))
    , m_prop_lo(jsi::PropNameID::forAscii(_env, "lo"))
    , m_prop_hi(jsi::PropNameID::forAscii(_env, "hi"))
    , m_prop_points(jsi::PropNameID::forAscii(_env, "points"))
    , m_prop_deletions(jsi::PropNameID::forAscii(_env, "deletions"))
    , m_prop_insertions(jsi::PropNameID::forAscii(_env, "insertions"))
    , m_prop_modifications(jsi::PropNameID::forAscii(_env, "modifications"))
    , m_prop_modificationsNew(jsi::PropNameID::forAscii(_env, "modificationsNew"))
    , m_prop_isDeleted(jsi::PropNameID::forAscii(_env, "isDeleted"))
    , m_prop_changedColumns(jsi::PropNameID::forAscii(_env, "changedColumns"))
    , m_prop_high(jsi::PropNameID::forAscii(_env, "high"))
    , m_prop_low(jsi::PropNameID::forAscii(_env, "low"))
{


    exports.setProperty(_env, "Helpers_get_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_table"), 1, Helpers_get_table));
    exports.setProperty(
        _env, "Helpers_get_keypath_mapping",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_get_keypath_mapping"), 1,
                                              Helpers_get_keypath_mapping));
    exports.setProperty(
        _env, "Helpers_results_append_query",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_results_append_query"),
                                              1, Helpers_results_append_query));
    exports.setProperty(
        _env, "Helpers_make_object_notifier",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_make_object_notifier"),
                                              1, Helpers_make_object_notifier));
    exports.setProperty(
        _env, "Helpers_set_binding_context",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_set_binding_context"), 1,
                                              Helpers_set_binding_context));
    exports.setProperty(_env, "Helpers_get_or_create_object_with_primary_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_or_create_object_with_primary_key"), 1,
                            Helpers_get_or_create_object_with_primary_key));
    exports.setProperty(
        _env, "Helpers_delete_data_for_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_delete_data_for_object"),
                                              1, Helpers_delete_data_for_object));
    exports.setProperty(
        _env, "Helpers_base64_decode",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_base64_decode"), 1,
                                              Helpers_base64_decode));
    exports.setProperty(
        _env, "Helpers_make_logger_factory",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_make_logger_factory"), 1,
                                              Helpers_make_logger_factory));
    exports.setProperty(_env, "Helpers_make_logger",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_make_logger"), 1, Helpers_make_logger));
    exports.setProperty(_env, "Helpers_consume_thread_safe_reference_to_shared_realm",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "Helpers_consume_thread_safe_reference_to_shared_realm"),
                            1, Helpers_consume_thread_safe_reference_to_shared_realm));
    exports.setProperty(_env, "Helpers_file_exists",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_file_exists"), 1, Helpers_file_exists));
    exports.setProperty(_env, "Helpers_get_results_description",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_results_description"), 1,
                            Helpers_get_results_description));
    exports.setProperty(_env, "Helpers_needs_file_format_upgrade",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_needs_file_format_upgrade"), 1,
                            Helpers_needs_file_format_upgrade));
    exports.setProperty(_env, "LogCategoryRef_set_default_level_threshold",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "LogCategoryRef_set_default_level_threshold"), 1,
                            LogCategoryRef_set_default_level_threshold));
    exports.setProperty(
        _env, "LogCategoryRef_get_category",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "LogCategoryRef_get_category"), 1,
                                              LogCategoryRef_get_category));
    exports.setProperty(
        _env, "Logger_set_default_logger",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Logger_set_default_logger"), 1,
                                              Logger_set_default_logger));
    exports.setProperty(
        _env, "ConstTableRef_get_column_type",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_column_type"),
                                              1, ConstTableRef_get_column_type));
    exports.setProperty(
        _env, "ConstTableRef_get_link_target",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_link_target"),
                                              1, ConstTableRef_get_link_target));
    exports.setProperty(
        _env, "ConstTableRef_get_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_object"), 1,
                                              ConstTableRef_get_object));
    exports.setProperty(
        _env, "ConstTableRef_try_get_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_try_get_object"),
                                              1, ConstTableRef_try_get_object));
    exports.setProperty(_env, "ConstTableRef_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "ConstTableRef_query"), 1, ConstTableRef_query));
    exports.setProperty(
        _env, "ConstTableRef_find_primary_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_find_primary_key"),
                                              1, ConstTableRef_find_primary_key));
    exports.setProperty(
        _env, "ConstTableRef_get_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_key"), 1,
                                              ConstTableRef_get_key));
    exports.setProperty(
        _env, "ConstTableRef_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_Symbol_iterator"),
                                              1, ConstTableRef_Symbol_iterator));
    exports.setProperty(
        _env, "TableRef_create_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_create_object"), 1,
                                              TableRef_create_object));
    exports.setProperty(
        _env, "TableRef_remove_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_remove_object"), 1,
                                              TableRef_remove_object));
    exports.setProperty(
        _env, "TableRef_get_link_target",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_get_link_target"), 1,
                                              TableRef_get_link_target));
    exports.setProperty(_env, "TableRef_clear",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_clear"),
                                                              1, TableRef_clear));
    exports.setProperty(_env, "TableRef_get_primary_key_column",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "TableRef_get_primary_key_column"), 1,
                            TableRef_get_primary_key_column));
    exports.setProperty(
        _env, "Obj_get_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_any"), 1, Obj_get_any));
    exports.setProperty(
        _env, "Obj_set_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_set_any"), 1, Obj_set_any));
    exports.setProperty(_env, "Obj_set_collection",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Obj_set_collection"), 1, Obj_set_collection));
    exports.setProperty(
        _env, "Obj_add_int",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_add_int"), 1, Obj_add_int));
    exports.setProperty(
        _env, "Obj_get_linked_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_linked_object"), 1,
                                              Obj_get_linked_object));
    exports.setProperty(
        _env, "Obj_get_backlink_count",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_backlink_count"), 1,
                                              Obj_get_backlink_count));
    exports.setProperty(
        _env, "Obj_get_backlink_view",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_backlink_view"), 1,
                                              Obj_get_backlink_view));
    exports.setProperty(_env, "Obj_create_and_set_linked_object",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Obj_create_and_set_linked_object"), 1,
                            Obj_create_and_set_linked_object));
    exports.setProperty(_env, "Obj_is_valid",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_is_valid"),
                                                              1, Obj_is_valid));
    exports.setProperty(_env, "Obj_get_table",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_table"),
                                                              1, Obj_get_table));
    exports.setProperty(
        _env, "Obj_get_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_key"), 1, Obj_get_key));
    exports.setProperty(_env, "Timestamp_make",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_make"),
                                                              1, Timestamp_make));
    exports.setProperty(
        _env, "Timestamp_get_seconds",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_get_seconds"), 1,
                                              Timestamp_get_seconds));
    exports.setProperty(
        _env, "Timestamp_get_nanoseconds",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_get_nanoseconds"), 1,
                                              Timestamp_get_nanoseconds));
    exports.setProperty(
        _env, "Geospatial_make_from_circle",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_circle"), 1,
                                              Geospatial_make_from_circle));
    exports.setProperty(
        _env, "Geospatial_make_from_box",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_box"), 1,
                                              Geospatial_make_from_box));
    exports.setProperty(
        _env, "Geospatial_make_from_polygon",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_polygon"),
                                              1, Geospatial_make_from_polygon));
    exports.setProperty(
        _env, "ObjLink_get_table_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ObjLink_get_table_key"), 1,
                                              ObjLink_get_table_key));
    exports.setProperty(_env, "ObjLink_get_obj_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "ObjLink_get_obj_key"), 1, ObjLink_get_obj_key));
    exports.setProperty(_env, "Query_get_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Query_get_table"), 1, Query_get_table));
    exports.setProperty(
        _env, "Query_get_description",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Query_get_description"), 1,
                                              Query_get_description));
    exports.setProperty(_env, "Results_size",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_size"),
                                                              1, Results_size));
    exports.setProperty(_env, "Results_index_of",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_index_of"), 1, Results_index_of));
    exports.setProperty(_env, "Results_index_of_obj",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_index_of_obj"), 1, Results_index_of_obj));
    exports.setProperty(_env, "Results_get_obj",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_obj"), 1, Results_get_obj));
    exports.setProperty(_env, "Results_get_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_any"), 1, Results_get_any));
    exports.setProperty(_env, "Results_get_list",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_list"), 1, Results_get_list));
    exports.setProperty(
        _env, "Results_get_dictionary",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_get_dictionary"), 1,
                                              Results_get_dictionary));
    exports.setProperty(
        _env, "Results_sort_by_names",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_sort_by_names"), 1,
                                              Results_sort_by_names));
    exports.setProperty(_env, "Results_snapshot",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_snapshot"), 1, Results_snapshot));
    exports.setProperty(
        _env, "Results_max",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_max"), 1, Results_max));
    exports.setProperty(
        _env, "Results_min",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_min"), 1, Results_min));
    exports.setProperty(_env, "Results_average",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_average"), 1, Results_average));
    exports.setProperty(
        _env, "Results_sum",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_sum"), 1, Results_sum));
    exports.setProperty(_env, "Results_clear",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_clear"),
                                                              1, Results_clear));
    exports.setProperty(_env, "Results_add_notification_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_add_notification_callback"), 1,
                            Results_add_notification_callback));
    exports.setProperty(_env, "Results_from_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_from_table"), 1, Results_from_table));
    exports.setProperty(
        _env, "Results_from_table_view",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_from_table_view"), 1,
                                              Results_from_table_view));
    exports.setProperty(_env, "Results_is_valid",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_is_valid"), 1, Results_is_valid));
    exports.setProperty(_env, "Results_get_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_query"), 1, Results_get_query));
    exports.setProperty(
        _env, "Results_get_object_type",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_get_object_type"), 1,
                                              Results_get_object_type));
    exports.setProperty(_env, "Results_get_type",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_type"), 1, Results_get_type));
    exports.setProperty(
        _env, "Realm_begin_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_begin_transaction"), 1,
                                              Realm_begin_transaction));
    exports.setProperty(
        _env, "Realm_commit_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_commit_transaction"), 1,
                                              Realm_commit_transaction));
    exports.setProperty(
        _env, "Realm_cancel_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_cancel_transaction"), 1,
                                              Realm_cancel_transaction));
    exports.setProperty(_env, "Realm_update_schema",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_update_schema"), 1, Realm_update_schema));
    exports.setProperty(_env, "Realm_compact",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_compact"),
                                                              1, Realm_compact));
    exports.setProperty(_env, "Realm_convert",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_convert"),
                                                              1, Realm_convert));
    exports.setProperty(_env, "Realm_verify_open",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_verify_open"), 1, Realm_verify_open));
    exports.setProperty(
        _env, "Realm_create_key_path_array",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_create_key_path_array"), 1,
                                              Realm_create_key_path_array));
    exports.setProperty(
        _env, "Realm_close",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_close"), 1, Realm_close));
    exports.setProperty(
        _env, "Realm_get_shared_realm",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_get_shared_realm"), 1,
                                              Realm_get_shared_realm));
    exports.setProperty(
        _env, "Realm_get_schema_version",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_get_schema_version"), 1,
                                              Realm_get_schema_version));
    exports.setProperty(_env, "Realm_config",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_config"),
                                                              1, Realm_config));
    exports.setProperty(_env, "Realm_schema",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_schema"),
                                                              1, Realm_schema));
    exports.setProperty(_env, "Realm_schema_version",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_schema_version"), 1, Realm_schema_version));
    exports.setProperty(
        _env, "Realm_is_in_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_in_transaction"), 1,
                                              Realm_is_in_transaction));
    exports.setProperty(
        _env, "Realm_is_in_migration",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_in_migration"), 1,
                                              Realm_is_in_migration));
    exports.setProperty(_env, "Realm_is_empty",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_empty"),
                                                              1, Realm_is_empty));
    exports.setProperty(_env, "Realm_is_closed",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_is_closed"), 1, Realm_is_closed));
    exports.setProperty(_env, "Realm_DOLLAR_addr",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_DOLLAR_addr"), 1, Realm_DOLLAR_addr));
    exports.setProperty(
        _env, "Realm_DOLLAR_resetSharedPtr",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_DOLLAR_resetSharedPtr"), 1,
                                              Realm_DOLLAR_resetSharedPtr));
    exports.setProperty(_env, "RealmCoordinator_clear_all_caches",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "RealmCoordinator_clear_all_caches"), 1,
                            RealmCoordinator_clear_all_caches));
    exports.setProperty(
        _env, "ObjectNotifier_add_callback",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ObjectNotifier_add_callback"), 1,
                                              ObjectNotifier_add_callback));
    exports.setProperty(
        _env, "NotificationToken_unregister",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "NotificationToken_unregister"),
                                              1, NotificationToken_unregister));
    exports.setProperty(
        _env, "NotificationToken_for_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "NotificationToken_for_object"),
                                              1, NotificationToken_for_object));
    exports.setProperty(
        _env, "IndexSet_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "IndexSet_Symbol_iterator"), 1,
                                              IndexSet_Symbol_iterator));
    exports.setProperty(_env, "Collection_get_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_get_any"), 1, Collection_get_any));
    exports.setProperty(
        _env, "Collection_as_results",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Collection_as_results"), 1,
                                              Collection_as_results));
    exports.setProperty(_env, "Collection_snapshot",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_snapshot"), 1, Collection_snapshot));
    exports.setProperty(_env, "Collection_get_type",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_get_type"), 1, Collection_get_type));
    exports.setProperty(
        _env, "Collection_get_object_schema",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Collection_get_object_schema"),
                                              1, Collection_get_object_schema));
    exports.setProperty(_env, "Collection_size",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_size"), 1, Collection_size));
    exports.setProperty(_env, "Collection_is_valid",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_is_valid"), 1, Collection_is_valid));
    exports.setProperty(_env, "List_get_obj",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_get_obj"),
                                                              1, List_get_obj));
    exports.setProperty(_env, "List_get_list",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_get_list"),
                                                              1, List_get_list));
    exports.setProperty(_env, "List_get_dictionary",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_get_dictionary"), 1, List_get_dictionary));
    exports.setProperty(
        _env, "List_move",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_move"), 1, List_move));
    exports.setProperty(
        _env, "List_remove",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_remove"), 1, List_remove));
    exports.setProperty(_env, "List_remove_all",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_remove_all"), 1, List_remove_all));
    exports.setProperty(
        _env, "List_swap",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_swap"), 1, List_swap));
    exports.setProperty(_env, "List_delete_all",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_delete_all"), 1, List_delete_all));
    exports.setProperty(_env, "List_insert_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_insert_any"), 1, List_insert_any));
    exports.setProperty(_env, "List_insert_embedded",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_insert_embedded"), 1, List_insert_embedded));
    exports.setProperty(
        _env, "List_insert_collection",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_insert_collection"), 1,
                                              List_insert_collection));
    exports.setProperty(_env, "List_set_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_set_any"),
                                                              1, List_set_any));
    exports.setProperty(_env, "List_set_embedded",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_set_embedded"), 1, List_set_embedded));
    exports.setProperty(_env, "List_set_collection",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_set_collection"), 1, List_set_collection));
    exports.setProperty(
        _env, "List_make",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_make"), 1, List_make));
    exports.setProperty(
        _env, "Set_get_obj",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_get_obj"), 1, Set_get_obj));
    exports.setProperty(_env, "Set_insert_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_insert_any"),
                                                              1, Set_insert_any));
    exports.setProperty(_env, "Set_remove_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_remove_any"),
                                                              1, Set_remove_any));
    exports.setProperty(_env, "Set_remove_all",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_remove_all"),
                                                              1, Set_remove_all));
    exports.setProperty(_env, "Set_delete_all",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_delete_all"),
                                                              1, Set_delete_all));
    exports.setProperty(
        _env, "Set_make",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_make"), 1, Set_make));
    exports.setProperty(_env, "Dictionary_get_list",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_get_list"), 1, Dictionary_get_list));
    exports.setProperty(
        _env, "Dictionary_get_dictionary",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_get_dictionary"), 1,
                                              Dictionary_get_dictionary));
    exports.setProperty(_env, "Dictionary_contains",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_contains"), 1, Dictionary_contains));
    exports.setProperty(_env, "Dictionary_add_key_based_notification_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_add_key_based_notification_callback"),
                            1, Dictionary_add_key_based_notification_callback));
    exports.setProperty(
        _env, "Dictionary_insert_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_any"), 1,
                                              Dictionary_insert_any));
    exports.setProperty(
        _env, "Dictionary_insert_embedded",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_embedded"), 1,
                                              Dictionary_insert_embedded));
    exports.setProperty(
        _env, "Dictionary_insert_collection",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_collection"),
                                              1, Dictionary_insert_collection));
    exports.setProperty(
        _env, "Dictionary_try_get_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_try_get_any"), 1,
                                              Dictionary_try_get_any));
    exports.setProperty(
        _env, "Dictionary_remove_all",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_remove_all"), 1,
                                              Dictionary_remove_all));
    exports.setProperty(_env, "Dictionary_try_erase",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_try_erase"), 1, Dictionary_try_erase));
    exports.setProperty(_env, "Dictionary_make",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_make"), 1, Dictionary_make));
    exports.setProperty(_env, "Dictionary_get_keys",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_get_keys"), 1, Dictionary_get_keys));
    exports.setProperty(
        _env, "Dictionary_get_values",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_get_values"), 1,
                                              Dictionary_get_values));
    exports.setProperty(
        _env, "Dictionary_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_Symbol_iterator"), 1,
                                              Dictionary_Symbol_iterator));
    exports.setProperty(_env, "JsPlatformHelpers_set_default_realm_file_directory",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_set_default_realm_file_directory"), 1,
                            JsPlatformHelpers_set_default_realm_file_directory));
    exports.setProperty(_env, "JsPlatformHelpers_default_realm_file_directory",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_default_realm_file_directory"),
                            1, JsPlatformHelpers_default_realm_file_directory));
    exports.setProperty(_env, "JsPlatformHelpers_ensure_directory_exists_for_file",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_ensure_directory_exists_for_file"), 1,
                            JsPlatformHelpers_ensure_directory_exists_for_file));
    exports.setProperty(_env, "JsPlatformHelpers_copy_bundled_realm_files",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_copy_bundled_realm_files"), 1,
                            JsPlatformHelpers_copy_bundled_realm_files));
    exports.setProperty(_env, "JsPlatformHelpers_remove_realm_files_from_directory",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_realm_files_from_directory"), 1,
                            JsPlatformHelpers_remove_realm_files_from_directory));
    exports.setProperty(
        _env, "JsPlatformHelpers_remove_file",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_file"),
                                              1, JsPlatformHelpers_remove_file));
    exports.setProperty(_env, "JsPlatformHelpers_remove_directory",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_directory"), 1,
                            JsPlatformHelpers_remove_directory));
    exports.setProperty(_env, "JsPlatformHelpers_exclude_from_icloud_backup",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_exclude_from_icloud_backup"), 1,
                            JsPlatformHelpers_exclude_from_icloud_backup));
    exports.setProperty(
        _env, "JsPlatformHelpers_get_cpu_arch",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_get_cpu_arch"),
                                              1, JsPlatformHelpers_get_cpu_arch));
    exports.setProperty(_env, "createWeakRef",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "createWeakRef"),
                                                              1, createWeakRef));
    exports.setProperty(
        _env, "lockWeakRef",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "lockWeakRef"), 1, lockWeakRef));
    ;

    using namespace std::placeholders; // for _1, _2, _3...
    exports.setProperty(
        _env, "injectInjectables",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "injectInjectables"), 1,
                                              std::bind(&RealmAddon::injectInjectables, this, _1, _2, _3, _4)));

    _env.global().setProperty(_env, "__RealmFuncs", exports);
}
jsi::Value Helpers_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_TableRef(
            _env, Helpers::get_table(JS_TO_SHARED_Realm(_env, args[0]), TableKey(int32_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_keypath_mapping([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_KeyPathMapping(_env, Helpers::get_keypath_mapping(JS_TO_SHARED_Realm(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_results_append_query([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(_env, Helpers::results_append_query(JS_TO_CLASS_Results(_env, args[0]),
                                                                         JS_TO_CLASS_Query(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_object_notifier([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_SHARED_ObjectNotifier(
            _env, Helpers::make_object_notifier(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Helpers::BindingContextMethods STRUCT_FROM_JS_BindingContext(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = Helpers::BindingContextMethods();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_didChange);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.did_change = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::didChange is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_beforeNotify);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.before_notify = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::beforeNotify is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaDidChange);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_did_change = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::schemaDidChange is required");
        }
    }
    return out;
}
jsi::Value Helpers_set_binding_context([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(Helpers::set_binding_context(JS_TO_SHARED_Realm(_env, args[0]),
                                                    STRUCT_FROM_JS_BindingContext(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_or_create_object_with_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, JS_FROM_CLASS_Obj(_env, std::get<0>(FWD(tup))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }(Helpers::get_or_create_object_with_primary_key(JS_TO_CLASS_TableRef(_env, args[0]),
                                                         JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_delete_data_for_object([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(Helpers::delete_data_for_object(
                    JS_TO_SHARED_Realm(_env, args[0]),
                    RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_base64_decode([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ([&](const auto& bd) -> jsi::Value {
            auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                           .callAsConstructor(_env, int(bd.size()))
                           .getObject(_env)
                           .getArrayBuffer(_env);
            memcpy(arr.data(_env), bd.data(), bd.size());
            return arr;
        }(Helpers::base64_decode(RealmAddon::self->wrapString((args[0]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_LoggerFactory(
            _env, Helpers::make_logger_factory(util::EventLoopDispatcher(
                      [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                       _thread = ThreadConfinementChecker()](std::string const& category, util::Logger::Level level,
                                                             std::string const& message) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(
                              _env, {([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(category))),
                                     [&] {
                                         static_assert(sizeof(util::Logger::Level) <= sizeof(int32_t),
                                                       "we only support enums up to 32 bits");
                                         return jsi::Value(_env, int(FWD(level)));
                                     }(),
                                     ([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(message)))})));
                      })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_logger([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Logger(
            _env, Helpers::make_logger(util::EventLoopDispatcher(
                      [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                       _thread = ThreadConfinementChecker()](std::string const& category, util::Logger::Level level,
                                                             std::string const& message) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(
                              _env, {([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(category))),
                                     [&] {
                                         static_assert(sizeof(util::Logger::Level) <= sizeof(int32_t),
                                                       "we only support enums up to 32 bits");
                                         return jsi::Value(_env, int(FWD(level)));
                                     }(),
                                     ([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(message)))})));
                      })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_consume_thread_safe_reference_to_shared_realm([[maybe_unused]] jsi::Runtime& _env,
                                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                                 [[maybe_unused]] const jsi::Value* args,
                                                                 [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Realm(_env, Helpers::consume_thread_safe_reference_to_shared_realm(
                                              JS_TO_CLASS_ThreadSafeReference(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_file_exists([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(
            bool(Helpers::file_exists(RealmAddon::self->wrapString((args[0]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_results_description([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(Helpers::get_results_description(JS_TO_CLASS_Results(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Property STRUCT_FROM_JS_Property(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = Property();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_name);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Property::name is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_publicName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.public_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::publicName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_type);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.type = PropertyType((FWD(field)).getNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Property::type is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_objectType);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.object_type = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::objectType is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_linkOriginPropertyName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.link_origin_property_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::linkOriginPropertyName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isPrimary);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_primary = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isPrimary is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isIndexed);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_indexed = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isIndexed is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isFulltextIndexed);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_fulltext_indexed = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isFulltextIndexed is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_columnKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.column_key = ColKey(bigIntToI64(_env, jsi::Value(_env, FWD(field))));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::columnKey is required");
        }
    }
    return out;
}
ObjectSchema STRUCT_FROM_JS_ObjectSchema(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = ObjectSchema();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_name);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "ObjectSchema::name is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_persistedProperties);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.persisted_properties = [&](jsi::Array vec) {
                auto out = std::vector<Property>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back(STRUCT_FROM_JS_Property(_env, vec.getValueAtIndex(_env, i)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::persistedProperties is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_computedProperties);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.computed_properties = [&](jsi::Array vec) {
                auto out = std::vector<Property>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back(STRUCT_FROM_JS_Property(_env, vec.getValueAtIndex(_env, i)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::computedProperties is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_primaryKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.primary_key = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::primaryKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_tableKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.table_key = TableKey(int32_t((FWD(field)).asNumber()));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::tableKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_tableType);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.table_type = ObjectSchema::ObjectType((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::tableType is required");
        }
    }
    return out;
}
RealmConfig STRUCT_FROM_JS_RealmConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = RealmConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_path);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.path = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "RealmConfig::path is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_cache);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.cache = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::cache is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_encryptionKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.encryption_key = ([&](auto&& v) -> std::vector<char> {
                auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                auto data = buf.data(_env);
                const auto size = buf.length(_env);
                if (size == 0)
                    return {};
                return std::vector<char>(data, data + size);
            })(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::encryptionKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_fifoFilesFallbackPath);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.fifo_files_fallback_path = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::fifoFilesFallbackPath is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_inMemory);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.in_memory = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::inMemory is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schema);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::vector<ObjectSchema>>() : [&](jsi::Array vec) {
                    auto out = std::vector<ObjectSchema>();

                    const size_t length = vec.length(_env);
                    out.reserve(length);
                    for (size_t i = 0; i < length; i++) {
                        out.push_back(STRUCT_FROM_JS_ObjectSchema(_env, vec.getValueAtIndex(_env, i)));
                    }
                    return out;
                }((FWD(val)).getObject(_env).getArray(_env));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schema is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_version = bigIntToI64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schemaVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaMode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_mode = SchemaMode((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schemaMode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_disableFormatUpgrade);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.disable_format_upgrade = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::disableFormatUpgrade is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_migrationFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.migration_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>, Schema&)>()
                           : std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>, Schema&)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> old_realm,
                                                                        std::shared_ptr<Realm> new_realm,
                                                                        Schema&) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(old_realm)),
                                                                     JS_FROM_SHARED_Realm(_env, FWD(new_realm))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::migrationFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_initializationFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.initialization_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>)>()
                           : std::function<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> realm) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(realm))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::initializationFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_shouldCompactOnLaunchFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.should_compact_on_launch_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<bool(uint64_t, uint64_t)>()
                           : std::function<bool(uint64_t, uint64_t)>(schedulerWrapBlockingFunction(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](uint64_t total_bytes,
                                                                        uint64_t used_bytes) -> bool {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return (_cb->call(_env, {bigIntFromU64(_env, FWD(total_bytes)),
                                                              bigIntFromU64(_env, FWD(used_bytes))}))
                                         .asBool();
                                 }));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::shouldCompactOnLaunchFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_automaticallyHandleBacklinksInMigrations);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.automatically_handle_backlinks_in_migrations = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::automaticallyHandleBacklinksInMigrations is required");
        }
    }
    return out;
}
jsi::Value Helpers_needs_file_format_upgrade([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool(Helpers::needs_file_format_upgrade(STRUCT_FROM_JS_RealmConfig(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Helpers& JS_TO_CLASS_Helpers(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Helpers_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Helpers&>::extract(_env, external));

    return *ptr;
}
jsi::Value LogCategoryRef_set_default_level_threshold([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<util::LogCategoryRef&>::extract(_env, args[0])))
                           .set_default_level_threshold(util::Logger::Level((args[1]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value LogCategoryRef_get_category([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_LogCategoryRef(_env, util::LogCategoryRef::get_category(RealmAddon::self->wrapString(
                                                      (args[0]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
util::LogCategoryRef& JS_TO_CLASS_LogCategoryRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_LogCategoryRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<util::LogCategoryRef&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_LogCategoryRef(jsi::Runtime& _env, util::LogCategoryRef val)
{

    return (*RealmAddon::self->m_cls_LogCategoryRef_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<util::LogCategoryRef, util::LogCategoryRef>::create(_env, std::move(val))});
}
jsi::Value Logger_set_default_logger([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(util::Logger::set_default_logger([&](auto&& val) {
                    return val.isNull() ? std::shared_ptr<util::Logger>() : JS_TO_SHARED_Logger(_env, FWD(val));
                }(args[0]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<util::Logger>& JS_TO_SHARED_Logger(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Logger_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<util::Logger>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Logger");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Logger(jsi::Runtime& _env, std::shared_ptr<util::Logger> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Logger_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<util::Logger>, std::shared_ptr<util::Logger>>::create(
                               _env, std::move(val))});
}
jsi::Value ConstTableRef_get_column_type([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&] {
            static_assert(sizeof(DataType::Type) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(_env, int((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                            .get_column_type(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))))));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_ConstTableRef(
            _env, (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                      .get_link_target(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(_env, (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                           .get_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_try_get_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_CLASS_Obj(_env, FWD(val));
        }((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                   .try_get_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Query(
            _env,
            (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                .query((args[1]).asString(_env).utf8(_env),
                       [&](jsi::Array vec) {
                           auto out = std::vector<mpark::variant<Mixed, std::vector<Mixed>>>();

                           const size_t length = vec.length(_env);
                           out.reserve(length);
                           for (size_t i = 0; i < length; i++) {
                               out.push_back(([&](auto&& arg) -> mpark::variant<Mixed, std::vector<Mixed>> {
                                   jsi::Value v = FWD(arg);
                                   if (v.isObject()) {
                                       auto obj = std::move(v).getObject(_env);
                                       const bool isArray = obj.isArray(_env);
                                       v = std::move(obj); // move back into a value
                                       if (isArray) {
                                           return [&](jsi::Array vec) {
                                               auto out = std::vector<Mixed>();

                                               const size_t length = vec.length(_env);
                                               out.reserve(length);
                                               for (size_t i = 0; i < length; i++) {
                                                   out.push_back(JS_TO_Mixed(_env, vec.getValueAtIndex(_env, i)));
                                               }
                                               return out;
                                           }((std::move(v)).getObject(_env).getArray(_env));
                                       }
                                   }
                                   return JS_TO_Mixed(_env, std::move(v));
                               })(vec.getValueAtIndex(_env, i)));
                           }
                           return out;
                       }((args[2]).getObject(_env).getArray(_env)),
                       JS_TO_CLASS_KeyPathMapping(_env, args[3])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_find_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromI64(_env, ((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                        .find_primary_key(JS_TO_Mixed(_env, args[1])))
                                       .value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))).get_key()).value));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(_env, "next",
                         jsi::Function::createFromHostFunction(
                             _env, RealmAddon::self->m_prop_next, 0,
                             [it = self.begin(), end = self.end()](
                                 [[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                                 auto ret = jsi::Object(_env);
                                 if (it == end) {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                                 }
                                 else {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_value,
                                                     JS_FROM_CLASS_Obj(_env, *it));
                                     ++it;
                                 }
                                 return ret;
                             }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
ConstTableRef& JS_TO_CLASS_ConstTableRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ConstTableRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ConstTableRef&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ConstTableRef(jsi::Runtime& _env, ConstTableRef val)
{

    return (*RealmAddon::self->m_cls_ConstTableRef_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ConstTableRef, ConstTableRef>::create(_env, std::move(val))});
}
jsi::Value TableRef_create_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Obj(
            _env,
            (**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))).create_object());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_remove_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                           .remove_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1]))))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_TableRef(
            _env, (**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                      .get_link_target(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))).clear()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_get_primary_key_column([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env,
                             ((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                                  .get_primary_key_column())
                                 .value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
TableRef& JS_TO_CLASS_TableRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_TableRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_TableRef(jsi::Runtime& _env, TableRef val)
{

    return (*RealmAddon::self->m_cls_TableRef_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<TableRef, ConstTableRef>::create(_env, std::move(val))});
}
jsi::Value Obj_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                       .get_any(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                       .set_any(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))), JS_TO_Mixed(_env, args[2]))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Obj(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .set_collection(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))),
                                                           CollectionType((args[2]).getNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_add_int([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Obj(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .add_int(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))),
                                                    bigIntToI64(_env, jsi::Value(_env, args[2]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_linked_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_CLASS_Obj(_env, FWD(val));
        }((*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                   .get_linked_object(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_backlink_count([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(asSigned((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_backlink_count())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_backlink_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_TableView(_env,
                                       (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .get_backlink_view(JS_TO_CLASS_TableRef(_env, args[1]),
                                                              ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_create_and_set_linked_object([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                      .create_and_set_linked_object(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_TableRef(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_table());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, ((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_key()).value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Obj& JS_TO_CLASS_Obj(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Obj_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Obj&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Obj(jsi::Runtime& _env, Obj val)
{

    return (*RealmAddon::self->m_cls_Obj_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Obj, Obj>::create(_env, std::move(val))});
}
const std::shared_ptr<Transaction>& JS_TO_SHARED_Transaction(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Transaction_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<Transaction>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Transaction");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Transaction(jsi::Runtime& _env, std::shared_ptr<Transaction> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Transaction_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<Transaction>, std::shared_ptr<Transaction>>::create(
                               _env, std::move(val))});
}
ObjectStore& JS_TO_CLASS_ObjectStore(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjectStore_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ObjectStore&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ObjectStore(jsi::Runtime& _env, ObjectStore val)
{

    return (*RealmAddon::self->m_cls_ObjectStore_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ObjectStore, ObjectStore>::create(_env, std::move(val))});
}
jsi::Value Timestamp_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Timestamp(
            _env, Timestamp(bigIntToI64(_env, jsi::Value(_env, args[0])), int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Timestamp_get_seconds([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, (*(&HostRefWrapper<Timestamp&>::extract(_env, args[0]))).get_seconds());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Timestamp_get_nanoseconds([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double((*(&HostRefWrapper<Timestamp&>::extract(_env, args[0]))).get_nanoseconds()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Timestamp& JS_TO_CLASS_Timestamp(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Timestamp_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Timestamp&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Timestamp(jsi::Runtime& _env, Timestamp val)
{

    return (*RealmAddon::self->m_cls_Timestamp_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Timestamp, Timestamp>::create(_env, std::move(val))});
}
GeoPoint STRUCT_FROM_JS_GeoPoint(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoPoint();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_longitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.longitude = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPoint::longitude is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_latitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.latitude = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPoint::latitude is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_altitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.altitude = (FWD(field)).asNumber();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "GeoPoint::altitude is required");
        }
    }
    return out;
}
GeoCircle STRUCT_FROM_JS_GeoCircle(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoCircle();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_radiusRadians);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.radius_radians = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoCircle::radiusRadians is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_center);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.center = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoCircle::center is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_circle([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoCircle(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
GeoBox STRUCT_FROM_JS_GeoBox(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoBox();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_lo);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.lo = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoBox::lo is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_hi);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.hi = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoBox::hi is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_box([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoBox(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
GeoPolygon STRUCT_FROM_JS_GeoPolygon(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoPolygon();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_points);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.points = [&](jsi::Array vec) {
                auto out = std::vector<std::vector<GeoPoint>>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back([&](jsi::Array vec) {
                        auto out = std::vector<GeoPoint>();

                        const size_t length = vec.length(_env);
                        out.reserve(length);
                        for (size_t i = 0; i < length; i++) {
                            out.push_back(STRUCT_FROM_JS_GeoPoint(_env, vec.getValueAtIndex(_env, i)));
                        }
                        return out;
                    }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPolygon::points is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_polygon([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoPolygon(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Geospatial& JS_TO_CLASS_Geospatial(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Geospatial_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Geospatial&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Geospatial(jsi::Runtime& _env, Geospatial val)
{

    return (*RealmAddon::self->m_cls_Geospatial_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Geospatial, Geospatial>::create(_env, std::move(val))});
}
jsi::Value ObjLink_get_table_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(((*(&HostRefWrapper<ObjLink&>::extract(_env, args[0]))).get_table_key()).value));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ObjLink_get_obj_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, ((*(&HostRefWrapper<ObjLink&>::extract(_env, args[0]))).get_obj_key()).value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
ObjLink& JS_TO_CLASS_ObjLink(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjLink_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ObjLink&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ObjLink(jsi::Runtime& _env, ObjLink val)
{

    return (*RealmAddon::self->m_cls_ObjLink_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ObjLink, ObjLink>::create(_env, std::move(val))});
}
query_parser::KeyPathMapping& JS_TO_CLASS_KeyPathMapping(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_KeyPathMapping_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<query_parser::KeyPathMapping&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_KeyPathMapping(jsi::Runtime& _env, query_parser::KeyPathMapping val)
{

    return (*RealmAddon::self->m_cls_KeyPathMapping_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<query_parser::KeyPathMapping, query_parser::KeyPathMapping>::create(
                               _env, std::move(val))});
}
jsi::Value Query_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_ConstTableRef(_env, (*(&HostRefWrapper<Query&>::extract(_env, args[0]))).get_table());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Query_get_description([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((*(&HostRefWrapper<Query&>::extract(_env, args[0]))).get_description()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Query& JS_TO_CLASS_Query(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Query_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Query&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Query(jsi::Runtime& _env, Query val)
{

    return (*RealmAddon::self->m_cls_Query_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Query, Query>::create(_env, std::move(val))});
}
SortDescriptor& JS_TO_CLASS_SortDescriptor(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SortDescriptor_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<SortDescriptor&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_SortDescriptor(jsi::Runtime& _env, SortDescriptor val)
{

    return (*RealmAddon::self->m_cls_SortDescriptor_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<SortDescriptor, SortDescriptor>::create(_env, std::move(val))});
}
TableView& JS_TO_CLASS_TableView(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_TableView_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<TableView&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_TableView(jsi::Runtime& _env, TableView val)
{

    return (*RealmAddon::self->m_cls_TableView_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<TableView, TableView>::create(_env, std::move(val))});
}
jsi::Value Results_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(asSigned((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).size())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_index_of([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(double(
            asSigned((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).index_of(JS_TO_Mixed(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_index_of_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(double(asSigned(
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).index_of(JS_TO_CLASS_Obj(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_any(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_list(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                                                  .get_dictionary(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_sort_by_names([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).sort([&](jsi::Array vec) {
                auto out = std::vector<std::pair<std::string, bool>>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back([&](const jsi::Array& arr) {
                        if (arr.length(_env) != 2u)
                            throw jsi::JSError(_env, "Need an array with exactly 2 elements");
                        return std::make_pair((arr.getValueAtIndex(_env, 0u)).asString(_env).utf8(_env),
                                              (arr.getValueAtIndex(_env, 1u)).asBool());
                    }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                }
                return out;
            }((args[1]).getObject(_env).getArray(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).snapshot());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_max([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .max(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_min([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .min(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_average([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .average(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_sum([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .sum(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).clear()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_CollectionChangeSet(jsi::Runtime& _env, const CollectionChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_deletions, JS_FROM_CLASS_IndexSet(_env, in.deletions));
    out.setProperty(_env, RealmAddon::self->m_prop_insertions, JS_FROM_CLASS_IndexSet(_env, in.insertions));
    out.setProperty(_env, RealmAddon::self->m_prop_modifications, JS_FROM_CLASS_IndexSet(_env, in.modifications));
    out.setProperty(_env, RealmAddon::self->m_prop_modificationsNew,
                    JS_FROM_CLASS_IndexSet(_env, in.modifications_new));
    return out;
}
jsi::Value Results_add_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                .add_notification_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](CollectionChangeSet const& changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_CollectionChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_from_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(
            _env, Results(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_ConstTableRef(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_from_table_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(
            _env, Results(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_TableView(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Query(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_query());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_object_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_object_type()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(_env, int((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_type()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Results& JS_TO_CLASS_Results(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Results_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Results&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Results(jsi::Runtime& _env, Results val)
{

    return (*RealmAddon::self->m_cls_Results_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Results, Results>::create(_env, std::move(val))});
}
jsi::Value Realm_begin_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).begin_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_commit_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).commit_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_cancel_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).cancel_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_update_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 6)
            throw jsi::JSError(_env, "expected 5 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                           .update_schema(
                               [&](jsi::Array vec) {
                                   auto out = std::vector<ObjectSchema>();

                                   const size_t length = vec.length(_env);
                                   out.reserve(length);
                                   for (size_t i = 0; i < length; i++) {
                                       out.push_back(STRUCT_FROM_JS_ObjectSchema(_env, vec.getValueAtIndex(_env, i)));
                                   }
                                   return out;
                               }((args[1]).getObject(_env).getArray(_env)),
                               bigIntToI64(_env, jsi::Value(_env, args[2])),
                               [&](auto&& val) {
                                   return val.isNull()
                                              ? std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>,
                                                                   Schema&)>()
                                              : std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>,
                                                                   Schema&)>(
                                                    [_cb = std::make_shared<jsi::Function>(
                                                         FWD(val).getObject(_env).getFunction(_env)),
                                                     _thread = ThreadConfinementChecker()](
                                                        std::shared_ptr<Realm> old_realm,
                                                        std::shared_ptr<Realm> new_realm, Schema&) -> void {
                                                        _thread.assertOnSameThread();
                                                        auto& _env = RealmAddon::self->m_rt;
                                                        return ((void)(_cb->call(
                                                            _env, {JS_FROM_SHARED_Realm(_env, FWD(old_realm)),
                                                                   JS_FROM_SHARED_Realm(_env, FWD(new_realm))})));
                                                    });
                               }(args[3]),
                               [&](auto&& val) {
                                   return val.isNull()
                                              ? std::function<void(std::shared_ptr<Realm>)>()
                                              : std::function<void(std::shared_ptr<Realm>)>(
                                                    [_cb = std::make_shared<jsi::Function>(
                                                         FWD(val).getObject(_env).getFunction(_env)),
                                                     _thread = ThreadConfinementChecker()](
                                                        std::shared_ptr<Realm> realm) -> void {
                                                        _thread.assertOnSameThread();
                                                        auto& _env = RealmAddon::self->m_rt;
                                                        return ((void)(_cb->call(
                                                            _env, {JS_FROM_SHARED_Realm(_env, FWD(realm))})));
                                                    });
                               }(args[4]),
                               (args[5]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_compact([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).compact()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_convert([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                           .convert(STRUCT_FROM_JS_RealmConfig(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_verify_open([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).verify_open()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_create_key_path_array([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, [&](auto&& vec) {
                    auto out = jsi::Array(_env, vec.size());
                    size_t i = 0;
                    for (auto&& e : vec) {
                        out.setValueAtIndex(_env, i++, [&](auto&& tup) {
                            auto out = jsi::Array(_env, 2);
                            out.setValueAtIndex(_env, 0, jsi::Value(double((std::get<0>(FWD(tup))).value)));
                            out.setValueAtIndex(_env, 1, bigIntFromI64(_env, (std::get<1>(FWD(tup))).value));
                            return out;
                        }(e));
                    }
                    return out;
                }(e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                   .create_key_path_array(
                       RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)), [&](jsi::Array vec) {
                           auto out = std::vector<std::string>();

                           const size_t length = vec.length(_env);
                           out.reserve(length);
                           for (size_t i = 0; i < length; i++) {
                               out.push_back((vec.getValueAtIndex(_env, i)).asString(_env).utf8(_env));
                           }
                           return out;
                       }((args[2]).getObject(_env).getArray(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).close()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_shared_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Realm(_env, Realm::get_shared_realm(STRUCT_FROM_JS_RealmConfig(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromI64(_env, Realm::get_schema_version(STRUCT_FROM_JS_RealmConfig(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_Property(jsi::Runtime& _env, const Property& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_name, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.name)));
    out.setProperty(_env, RealmAddon::self->m_prop_publicName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.public_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_type, [&] {
        static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.type));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_objectType, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.object_type)));
    out.setProperty(_env, RealmAddon::self->m_prop_linkOriginPropertyName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.link_origin_property_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_isPrimary, jsi::Value(bool(in.is_primary)));
    out.setProperty(_env, RealmAddon::self->m_prop_isIndexed, jsi::Value(bool(in.is_indexed)));
    out.setProperty(_env, RealmAddon::self->m_prop_isFulltextIndexed, jsi::Value(bool(in.is_fulltext_indexed)));
    out.setProperty(_env, RealmAddon::self->m_prop_columnKey, bigIntFromI64(_env, (in.column_key).value));
    return out;
}
jsi::Value STRUCT_TO_JS_ObjectSchema(jsi::Runtime& _env, const ObjectSchema& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_name, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.name)));
    out.setProperty(_env, RealmAddon::self->m_prop_persistedProperties, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, STRUCT_TO_JS_Property(_env, e));
        }
        return out;
    }(in.persisted_properties));
    out.setProperty(_env, RealmAddon::self->m_prop_computedProperties, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, STRUCT_TO_JS_Property(_env, e));
        }
        return out;
    }(in.computed_properties));
    out.setProperty(_env, RealmAddon::self->m_prop_primaryKey, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.primary_key)));
    out.setProperty(_env, RealmAddon::self->m_prop_tableKey, jsi::Value(double((in.table_key).value)));
    out.setProperty(_env, RealmAddon::self->m_prop_tableType, [&] {
        static_assert(sizeof(ObjectSchema::ObjectType) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.table_type));
    }());
    return out;
}
jsi::Value STRUCT_TO_JS_RealmConfig(jsi::Runtime& _env, const RealmConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_path, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.path)));
    out.setProperty(_env, RealmAddon::self->m_prop_cache, jsi::Value(bool(in.cache)));
    out.setProperty(_env, RealmAddon::self->m_prop_encryptionKey, ([&](const auto& bd) -> jsi::Value {
                        auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                                       .callAsConstructor(_env, int(bd.size()))
                                       .getObject(_env)
                                       .getArrayBuffer(_env);
                        memcpy(arr.data(_env), bd.data(), bd.size());
                        return arr;
                    }(in.encryption_key)));
    out.setProperty(_env, RealmAddon::self->m_prop_fifoFilesFallbackPath, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.fifo_files_fallback_path)));
    out.setProperty(_env, RealmAddon::self->m_prop_inMemory, jsi::Value(bool(in.in_memory)));
    out.setProperty(_env, RealmAddon::self->m_prop_schema, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_ObjectSchema(_env, e));
            }
            return out;
        }(*FWD(opt));
    }(in.schema));
    out.setProperty(_env, RealmAddon::self->m_prop_schemaVersion, bigIntFromI64(_env, in.schema_version));
    out.setProperty(_env, RealmAddon::self->m_prop_schemaMode, [&] {
        static_assert(sizeof(SchemaMode) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.schema_mode));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_disableFormatUpgrade, jsi::Value(bool(in.disable_format_upgrade)));
    out.setProperty(_env, RealmAddon::self->m_prop_automaticallyHandleBacklinksInMigrations,
                    jsi::Value(bool(in.automatically_handle_backlinks_in_migrations)));
    return out;
}
jsi::Value Realm_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_RealmConfig(
            _env, (**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).config());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_ObjectSchema(_env, e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).schema());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env,
                             (**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).schema_version());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_in_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_in_transaction()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_in_migration([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_in_migration()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_empty([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_empty()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_closed([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_closed()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_DOLLAR_addr([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(double(
            reinterpret_cast<intptr_t>(&(**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).reset()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<Realm>& JS_TO_SHARED_Realm(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Realm_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Realm");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Realm(jsi::Runtime& _env, std::shared_ptr<Realm> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Realm_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::shared_ptr<Realm>, std::shared_ptr<Realm>>::create(
                                     _env, std::move(val))});
}
jsi::Value RealmCoordinator_clear_all_caches([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)(_impl::RealmCoordinator::clear_all_caches()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<_impl::RealmCoordinator>& JS_TO_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                                              const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_RealmCoordinator_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<_impl::RealmCoordinator>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "RealmCoordinator");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_RealmCoordinator(jsi::Runtime& _env, std::shared_ptr<_impl::RealmCoordinator> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_RealmCoordinator_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<_impl::RealmCoordinator>,
                                       std::shared_ptr<_impl::RealmCoordinator>>::create(_env, std::move(val))});
}
jsi::Value STRUCT_TO_JS_ObjectChangeSet(jsi::Runtime& _env, const ObjectChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_isDeleted, jsi::Value(bool(in.is_deleted)));
    out.setProperty(_env, RealmAddon::self->m_prop_changedColumns, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, bigIntFromI64(_env, (e).value));
        }
        return out;
    }(in.changed_columns));
    return out;
}
jsi::Value ObjectNotifier_add_callback([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return bigIntFromU64(
            _env,
            (**(&HostRefWrapper<std::shared_ptr<_impl::ObjectNotifier>&>::extract(_env, args[0])))
                .add_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](ObjectChangeSet changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_ObjectChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<_impl::ObjectNotifier>& JS_TO_SHARED_ObjectNotifier(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjectNotifier_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<_impl::ObjectNotifier>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "ObjectNotifier");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_ObjectNotifier(jsi::Runtime& _env, std::shared_ptr<_impl::ObjectNotifier> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_ObjectNotifier_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<_impl::ObjectNotifier>,
                                       std::shared_ptr<_impl::ObjectNotifier>>::create(_env, std::move(val))});
}
jsi::Value NotificationToken_unregister([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<NotificationToken&>::extract(_env, args[0]))).unregister()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value NotificationToken_for_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(_env, NotificationToken(JS_TO_SHARED_ObjectNotifier(_env, args[0]),
                                                                       bigIntToU64(_env, jsi::Value(_env, args[1]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
NotificationToken& JS_TO_CLASS_NotificationToken(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_NotificationToken_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<NotificationToken&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_NotificationToken(jsi::Runtime& _env, NotificationToken val)
{

    return (*RealmAddon::self->m_cls_NotificationToken_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<NotificationToken, NotificationToken>::create(_env, std::move(val))});
}
jsi::Value IndexSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (*(&HostRefWrapper<IndexSet&>::extract(_env, args[0])));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(
            _env, "next",
            jsi::Function::createFromHostFunction(
                _env, RealmAddon::self->m_prop_next, 0,
                [it = self.begin(),
                 end = self.end()]([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                    auto ret = jsi::Object(_env);
                    if (it == end) {
                        ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                    }
                    else {
                        ret.setProperty(
                            _env, RealmAddon::self->m_prop_value,

                            [&](auto&& tup) {
                                auto out = jsi::Array(_env, 2);
                                out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
                                out.setValueAtIndex(_env, 1, jsi::Value(double(asSigned(std::get<1>(FWD(tup))))));
                                return out;
                            }(*it));
                        ++it;
                    }
                    return ret;
                }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
IndexSet& JS_TO_CLASS_IndexSet(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_IndexSet_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<IndexSet&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_IndexSet(jsi::Runtime& _env, IndexSet val)
{

    return (*RealmAddon::self->m_cls_IndexSet_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<IndexSet, IndexSet>::create(_env, std::move(val))});
}
jsi::Value Collection_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(_env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0])))
                                       .get_any(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_as_results([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).as_results());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).snapshot());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(
                _env, int((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).get_type()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_get_object_schema([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_ObjectSchema(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).get_object_schema());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            double(asSigned((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).size())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Collection& JS_TO_CLASS_Collection(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Collection_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<object_store::Collection&>::extract(_env, external));

    return *ptr;
}
jsi::Value List_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get_list(int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get_dictionary(int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_move([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .move(size_t(ptrdiff_t((args[1]).asNumber())), size_t(ptrdiff_t((args[2]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_remove([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove(size_t(ptrdiff_t((args[1]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_swap([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .swap(size_t(ptrdiff_t((args[1]).asNumber())), size_t(ptrdiff_t((args[2]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .delete_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_any(size_t(ptrdiff_t((args[1]).asNumber())), JS_TO_Mixed(_env, args[2]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .insert_embedded(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_collection(int32_t((args[1]).asNumber()), CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .set_any(size_t(ptrdiff_t((args[1]).asNumber())), JS_TO_Mixed(_env, args[2]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .set_embedded(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .set_collection(int32_t((args[1]).asNumber()), CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_List(_env, List(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                             ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
List& JS_TO_CLASS_List(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_List_extractor).call(_env, &val, size_t(1));
    const auto ptr = static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_List(jsi::Runtime& _env, List val)
{

    return (*RealmAddon::self->m_cls_List_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<List, object_store::Collection>::create(_env, std::move(val))});
}
jsi::Value Set_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(_env, (*static_cast<object_store::Set*>(
                                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                           .get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .insert_any(JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_remove_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .remove_any(JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Set*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Set*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .delete_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Set(_env,
                                 object_store::Set(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                                   ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Set& JS_TO_CLASS_Set(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Set_extractor).call(_env, &val, size_t(1));
    const auto ptr =
        static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Set(jsi::Runtime& _env, object_store::Set val)
{

    return (*RealmAddon::self->m_cls_Set_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<object_store::Set, object_store::Collection>::create(_env, std::move(val))});
}
jsi::Value Dictionary_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(_env, (*static_cast<object_store::Dictionary*>(
                                             (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                            .get_list((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_dictionary([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(_env,
                                        (*static_cast<object_store::Dictionary*>(
                                             (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                            .get_dictionary((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_contains([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<object_store::Dictionary*>(
                                    (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                   .contains(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_DictionaryChangeSet(jsi::Runtime& _env, const DictionaryChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_deletions, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.deletions));
    out.setProperty(_env, RealmAddon::self->m_prop_insertions, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.insertions));
    out.setProperty(_env, RealmAddon::self->m_prop_modifications, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.modifications));
    return out;
}
jsi::Value Dictionary_add_key_based_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(
            _env,
            (*static_cast<object_store::Dictionary*>(
                 (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                .add_key_based_notification_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](DictionaryChangeSet changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_DictionaryChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Dictionary*>(
               (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .insert_any(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)),
                               JS_TO_Mixed(_env, args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_embedded([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<object_store::Dictionary*>(
                       (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .insert_embedded(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_collection([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<object_store::Dictionary*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_collection((args[1]).asString(_env).utf8(_env),
                                              CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_try_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*static_cast<object_store::Dictionary*>(
               (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .try_get_any(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Dictionary*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_try_erase([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<object_store::Dictionary*>(
                                    (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                   .try_erase(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Dictionary(
            _env, object_store::Dictionary(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                           ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_keys([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*static_cast<object_store::Dictionary*>(
                                                (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                               .get_keys());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_values([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*static_cast<object_store::Dictionary*>(
                                                (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                               .get_values());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (*static_cast<object_store::Dictionary*>(
            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(
            _env, "next",
            jsi::Function::createFromHostFunction(
                _env, RealmAddon::self->m_prop_next, 0,
                [it = self.begin(),
                 end = self.end()]([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                    auto ret = jsi::Object(_env);
                    if (it == end) {
                        ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                    }
                    else {
                        ret.setProperty(_env, RealmAddon::self->m_prop_value,

                                        [&](auto&& tup) {
                                            auto out = jsi::Array(_env, 2);
                                            out.setValueAtIndex(_env, 0, JS_FROM_Mixed(_env, std::get<0>(FWD(tup))));
                                            out.setValueAtIndex(_env, 1, JS_FROM_Mixed(_env, std::get<1>(FWD(tup))));
                                            return out;
                                        }(*it));
                        ++it;
                    }
                    return ret;
                }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Dictionary& JS_TO_CLASS_Dictionary(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Dictionary_extractor).call(_env, &val, size_t(1));
    const auto ptr =
        static_cast<object_store::Dictionary*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Dictionary(jsi::Runtime& _env, object_store::Dictionary val)
{

    return (*RealmAddon::self->m_cls_Dictionary_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<object_store::Dictionary, object_store::Collection>::create(
                                     _env, std::move(val))});
}
std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>& JS_TO_CLASS_LoggerFactory(jsi::Runtime& _env,
                                                                                             const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_LoggerFactory_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>&>::extract(
        _env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_LoggerFactory(jsi::Runtime& _env,
                                       std::function<std::shared_ptr<util::Logger>(util::Logger::Level)> val)
{

    return (*RealmAddon::self->m_cls_LoggerFactory_ctor)
        .callAsConstructor(
            _env,
            {HostObjClassWrapper<
                std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>,
                std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>>::create(_env, std::move(val))});
}
ThreadSafeReference& JS_TO_CLASS_ThreadSafeReference(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ThreadSafeReference_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ThreadSafeReference&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ThreadSafeReference(jsi::Runtime& _env, ThreadSafeReference val)
{

    return (*RealmAddon::self->m_cls_ThreadSafeReference_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<ThreadSafeReference, ThreadSafeReference>::create(_env, std::move(val))});
}
const std::shared_ptr<util::Scheduler>& JS_TO_SHARED_Scheduler(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Scheduler_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<util::Scheduler>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Scheduler");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Scheduler(jsi::Runtime& _env, std::shared_ptr<util::Scheduler> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Scheduler_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<util::Scheduler>, std::shared_ptr<util::Scheduler>>::create(
                      _env, std::move(val))});
}
jsi::Value JsPlatformHelpers_set_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::set_default_realm_file_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(JsPlatformHelpers::default_realm_file_directory()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_ensure_directory_exists_for_file([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::ensure_directory_exists_for_file((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_copy_bundled_realm_files([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)(JsPlatformHelpers::copy_bundled_realm_files()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_realm_files_from_directory([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_realm_files_from_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_file([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_file((args[0]).asString(_env).utf8(_env))), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_directory([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_exclude_from_icloud_backup([[maybe_unused]] jsi::Runtime& _env,
                                                        [[maybe_unused]] const jsi::Value& thisValue,
                                                        [[maybe_unused]] const jsi::Value* args,
                                                        [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(JsPlatformHelpers::exclude_from_icloud_backup((args[0]).asString(_env).utf8(_env),
                                                                     (args[1]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_get_cpu_arch([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(JsPlatformHelpers::get_cpu_arch()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
JsPlatformHelpers& JS_TO_CLASS_JsPlatformHelpers(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_JsPlatformHelpers_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<JsPlatformHelpers&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_Mixed(jsi::Runtime& _env, Mixed val)
{
    if (val.is_null())
        return jsi::Value::null();
    switch (val.get_type()) {

        case DataType::Type::Int:
            return bigIntFromI64(_env, val.get_int());


        case DataType::Type::Bool:
            return jsi::Value(bool(val.get_bool()));


        case DataType::Type::Float:
            return (*RealmAddon::self->m_cls_Float_ctor)
                .callAsConstructor(_env, {jsi::Value(double(val.get_float()))});


        case DataType::Type::Double:
            return jsi::Value(double(val.get_double()));


        case DataType::Type::String:
            return ([&](auto&& sd) {
                return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
            }(val.get_string()));


        case DataType::Type::Binary:
            return ([&](const auto& bd) -> jsi::Value {
                auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                               .callAsConstructor(_env, int(bd.size()))
                               .getObject(_env)
                               .getArrayBuffer(_env);
                memcpy(arr.data(_env), bd.data(), bd.size());
                return arr;
            }(val.get_binary()));


        case DataType::Type::Timestamp:
            return JS_FROM_CLASS_Timestamp(_env, val.get_timestamp());


        case DataType::Type::Decimal:
            return (*RealmAddon::self->m_cls_Decimal128_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_decimal().to_string()))});


        case DataType::Type::ObjectId:
            return (*RealmAddon::self->m_cls_ObjectId_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_object_id().to_string()))});


        case DataType::Type::UUID:
            return (*RealmAddon::self->m_cls_UUID_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_uuid().to_string()))});


        case DataType::Type::TypedLink:
            return JS_FROM_CLASS_ObjLink(_env, val.get_link());


        case DataType::Type::Link:
            return bigIntFromI64(_env, (val.get<ObjKey>()).value);


            // Silence these warnings as they might be confusing to developers as they build the binding

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wswitch"

        // We are returning sentinel values for lists and dictionaries in the
        // form of Symbol singletons. This is due to not being able to construct
        // the actual list or dictionary in the current context.
        case realm::type_List:
            return (*RealmAddon::self->m_cls_Symbol_for_ctor).call(_env, "Realm.List");

        case realm::type_Dictionary:
            return (*RealmAddon::self->m_cls_Symbol_for_ctor).call(_env, "Realm.Dictionary");

#pragma GCC diagnostic pop

        // The remaining cases are never stored in a Mixed.
        case DataType::Type::Mixed:
            break;
    }
    REALM_UNREACHABLE();
}
Mixed JS_TO_Mixed(jsi::Runtime& _env, auto&& val)
{
    if (val.isNull())
        return Mixed();
    if (val.isString())
        return RealmAddon::self->wrapString((val).asString(_env).utf8(_env));
    if (val.isNumber())
        return (val).asNumber();
    if (val.isBigInt())
        return bigIntToI64(_env, jsi::Value(_env, val));
    if (val.isBool())
        return (val).asBool();
    if (val.isObject()) {
        auto obj = std::move(val).asObject(_env);
        if (obj.isArrayBuffer(_env)) {
            return ([&](auto&& v) -> BinaryData {
                auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                auto data = buf.data(_env);
                return BinaryData(data ? reinterpret_cast<const char*>(data) : "", buf.length(_env));
            })(jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Obj_ctor))) {
            return JS_TO_CLASS_Obj(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Timestamp_ctor))) {
            return JS_TO_CLASS_Timestamp(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Float_ctor))) {
            return float((jsi::Value(std::move(obj)))
                             .asObject(_env)
                             .getProperty(_env, RealmAddon::self->m_prop_value)
                             .asNumber());
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_ObjLink_ctor))) {
            return JS_TO_CLASS_ObjLink(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_ObjectId_ctor))) {
            return ObjectId(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Decimal128_ctor))) {
            return Decimal128(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_UUID_ctor))) {
            return UUID(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Long_ctor))) {
            return bigIntToI64(_env, jsi::Value(_env, jsi::Value(std::move(obj))));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Geospatial_ctor))) {
            // This needs its own case because the constructor of Mixed for Geospatial requires a pointer
            return &JS_TO_CLASS_Geospatial(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.isFunction(_env)) {
            throw jsi::JSError(_env, "Unable to convert a function to a Mixed");
        }
        else if (obj.isHostObject(_env)) {
            throw jsi::JSError(_env, "Unable to convert a native host object to a Mixed");
        }

        // TODO should we check for "boxed" values like 'new Number(1)'?

        const auto ctorName =
            obj.getProperty(_env, "constructor").getObject(_env).getProperty(_env, "name").asString(_env).utf8(_env);
        throw jsi::JSError(_env, "Unable to convert an object with ctor '" + ctorName + "' to a Mixed");
    }
    // NOTE: must not treat undefined as null here, because that makes optional<Mixed> ambiguous.
    throw jsi::JSError(_env, "Can't convert " + val.toString(_env).utf8(_env) + " to Mixed");
}
int64_t bigIntToI64(jsi::Runtime& _env, auto&& val)
{
    if (val.isBigInt())
        return FWD(val).asBigInt(_env).asInt64(_env);

    auto obj = FWD(val).asObject(_env);
    auto high = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_high).asNumber()));
    auto low = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_low).asNumber()));
    return (int64_t(high) << 32) | low;
}
uint64_t bigIntToU64(jsi::Runtime& _env, auto&& val)
{
    if (val.isBigInt())
        return FWD(val).asBigInt(_env).asUint64(_env);

    auto obj = FWD(val).asObject(_env);
    auto high = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_high).asNumber()));
    auto low = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_low).asNumber()));
    return (uint64_t(high) << 32) | low;
}
jsi::Value bigIntFromI64(jsi::Runtime& _env, int64_t val)
{
    if (RealmAddon::self->m_on_hermes)
        return jsi::BigInt::fromInt64(_env, val);

    return (*RealmAddon::self->m_cls_Long_ctor)
        .callAsConstructor(_env, {
                                     jsi::Value(int(val)),       // low
                                     jsi::Value(int(val >> 32)), // high
                                     jsi::Value(false),          // unsigned
                                 });
}
jsi::Value bigIntFromU64(jsi::Runtime& _env, uint64_t val)
{
    if (RealmAddon::self->m_on_hermes)
        return jsi::BigInt::fromUint64(_env, val);

    return (*RealmAddon::self->m_cls_Long_ctor)
        .callAsConstructor(_env, {
                                     jsi::Value(int(val)),       // low
                                     jsi::Value(int(val >> 32)), // high
                                     jsi::Value(true),           // unsigned
                                 });
}
jsi::Value createWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 argument");
        if (!args[0].isObject())
            throw jsi::JSError(_env, "expected an object");
        return jsi::Object::createFromHostObject(_env,
                                                 std::make_shared<WeakObjectWrapper>(_env, args[0].getObject(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value lockWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 argument");
        if (!args[0].isObject())
            throw jsi::JSError(_env, "expected an object");
        auto obj = args[0].getObject(_env);
        if (!obj.isHostObject<WeakObjectWrapper>(_env))
            throw jsi::JSError(_env, "expected a WeakObjectWrapper");
        return std::move(obj).getHostObject<WeakObjectWrapper>(_env)->ref.lock(_env);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}

} // namespace

extern "C" {
void realm_jsi_invalidate_caches()
{
    // Clear the default logger, to prevent it from holding on to a pointer that was released
    realm::util::LogCategory::get_category(realm::util::LogCategory::realm.get_name())
        .set_default_level_threshold(realm::util::Logger::Level::off);
    realm::util::Logger::set_default_logger(nullptr);
    // Close all cached Realms
    realm::_impl::RealmCoordinator::clear_all_caches();
    // Blow away the addon state.
    RealmAddon::self.reset();
}
void realm_jsi_init(jsi::Runtime& rt, jsi::Object& exports)
{
    realm_jsi_invalidate_caches();
    RealmAddon::self = std::make_unique<RealmAddon>(rt, exports);
}
} // extern "C"

} // namespace realm::js::JSI
