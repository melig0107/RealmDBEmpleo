"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressRealmPromise = void 0;
const binding_1 = require("./binding");
const flags_1 = require("./flags");
const indirect_1 = require("./indirect");
const Configuration_1 = require("./Configuration");
const PromiseHandle_1 = require("./PromiseHandle");
class ProgressRealmPromise {
    /** @internal */
    static instances = new Set();
    /**
     * Cancels all unresolved `ProgressRealmPromise` instances.
     * @internal
     */
    static cancelAll() {
        for (const promiseRef of ProgressRealmPromise.instances) {
            promiseRef.deref()?.cancel();
        }
        ProgressRealmPromise.instances.clear();
    }
    /** @internal */
    handle = new PromiseHandle_1.PromiseHandle();
    /** @internal */
    timeoutPromise = null;
    /**
     * Token used for unregistering the progress notifier.
     * @internal
     */
    notifierToken = null;
    /** @internal */
    constructor(config) {
        if (flags_1.flags.ALLOW_CLEAR_TEST_STATE) {
            ProgressRealmPromise.instances.add(new binding_1.binding.WeakRef(this));
        }
        try {
            (0, Configuration_1.validateConfiguration)(config);
            const realm = new indirect_1.indirect.Realm(config);
            this.handle.resolve(realm);
        }
        catch (err) {
            if (this.notifierToken !== null) {
                this.notifierToken = null;
            }
            this.handle.reject(err);
        }
    }
    /**
     * Cancels the download of the Realm
     * If multiple `ProgressRealmPromise` instances are in progress for the same Realm, then canceling one of them
     * will cancel all of them.
     */
    cancel() {
        this.timeoutPromise?.cancel();
        if (this.notifierToken !== null) {
            this.notifierToken = null;
        }
        // Tell anything awaiting the promise
        this.rejectAsCanceled();
    }
    then = this.handle.promise.then.bind(this.handle.promise);
    catch = this.handle.promise.catch.bind(this.handle.promise);
    finally = this.handle.promise.finally.bind(this.handle.promise);
    /** @internal */
    rejectAsCanceled() {
        const err = new Error("Async open canceled");
        this.handle.reject(err);
    }
    get [Symbol.toStringTag]() {
        return ProgressRealmPromise.name;
    }
}
exports.ProgressRealmPromise = ProgressRealmPromise;
//# sourceMappingURL=ProgressRealmPromise.js.map