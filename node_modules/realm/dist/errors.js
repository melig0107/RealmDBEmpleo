"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertySchemaParseError = exports.ObjectSchemaParseError = exports.SchemaParseError = exports.TimeoutError = exports.IllegalConstructorError = exports.TypeAssertionError = exports.AssertionError = void 0;
class AssertionError extends Error {
    /** @internal */
    constructor(message = "Assertion failed!") {
        super(message);
    }
}
exports.AssertionError = AssertionError;
class TypeAssertionError extends AssertionError {
    expected;
    value;
    /** @internal */
    static deriveType(value) {
        if (typeof value === "object") {
            if (value === null) {
                return "null";
            }
            else {
                const name = value.constructor.name;
                if (name === "Object") {
                    return "an object";
                }
                else if (name === "Array") {
                    return "an array";
                }
                else {
                    return "an instance of " + name;
                }
            }
        }
        else if (typeof value === "undefined") {
            return typeof value;
        }
        else if (typeof value === "function") {
            return `a function or class named ${value.name}`;
        }
        else if (typeof value === "number") {
            if (Number.isNaN(value)) {
                return "NaN";
            }
            else if (!Number.isInteger(value)) {
                return "a decimal number";
            }
            else {
                return "a number";
            }
        }
        else {
            return "a " + typeof value;
        }
    }
    /**
     * Get an error message for when the target's value is of
     * the wrong type. Single quotes are added around the target
     * string if it does not already contain one.
     * @internal
     */
    static message(expected, value, target) {
        const actual = TypeAssertionError.deriveType(value);
        if (target) {
            target = target.includes("'") ? target : `'${target}'`;
        }
        else {
            target = "value";
        }
        return `Expected ${target} to be ${expected}, got ${actual}`;
    }
    /** @internal */
    constructor(/** @internal */ expected, /** @internal */ value, target) {
        super(TypeAssertionError.message(expected, value, target));
        this.expected = expected;
        this.value = value;
    }
    /** @internal */
    rename(name) {
        this.message = TypeAssertionError.message(this.expected, this.value, name);
    }
}
exports.TypeAssertionError = TypeAssertionError;
class IllegalConstructorError extends Error {
    constructor(type) {
        super(`Illegal constructor: ${type} objects are read from managed objects only.`);
    }
}
exports.IllegalConstructorError = IllegalConstructorError;
class TimeoutError extends Error {
    constructor(message) {
        super(`Timed out: ${message}`);
    }
}
exports.TimeoutError = TimeoutError;
class SchemaParseError extends Error {
    /** @internal */
    constructor(message) {
        super(message);
    }
}
exports.SchemaParseError = SchemaParseError;
class ObjectSchemaParseError extends SchemaParseError {
    objectName;
    /** @internal */
    constructor(message, info) {
        const displayName = info.objectName ? `object '${info.objectName}'` : "unnamed object";
        super(`Invalid schema for ${displayName}: ${message}`);
        this.objectName = info.objectName;
    }
}
exports.ObjectSchemaParseError = ObjectSchemaParseError;
class PropertySchemaParseError extends SchemaParseError {
    objectName;
    propertyName;
    /** @internal */
    constructor(message, info) {
        super(`Invalid type declaration for property '${info.propertyName}' on '${info.objectName}': ${message}`);
        this.objectName = info.objectName;
        this.propertyName = info.propertyName;
    }
}
exports.PropertySchemaParseError = PropertySchemaParseError;
//# sourceMappingURL=errors.js.map